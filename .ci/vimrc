syntax off
filetype plugin indent on
set nocompatible

set shortmess=filnxtToO

if $CI == "true"
    set rtp+=~/.vim/syntastic
    set rtp+=~/.vim/vim-hdl
else
    set rtp+=~/dot_vim/syntastic
    set rtp+=~/dot_vim/vim-hdl
endif

if has('python')
    let s:using_python2 = 1
elseif has('python3')
    let s:using_python2 = 0
else
    throw "Unable to identify Python version"
endif

function! s:Pyeval( eval_string ) "{ Inspired on YCM
  if s:using_python2
    return pyeval( a:eval_string )
  endif
  return py3eval( a:eval_string )
endfunction
"}
"
let s:python_until_eof = s:using_python2 ? "python << EOF" : "python3 << EOF"
let s:python_command = s:using_python2 ? "py " : "py3 "

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 1

let g:syntastic_vhdl_vimhdl_sort = 0
let g:syntastic_vhdl_checkers = ['vimhdl']

" To avoid Press "ENTER..." message
set cmdheight=10

function! s:SetupPythonEnv() abort

  exec s:python_until_eof
from __future__ import print_function
import logging
import os
import os.path as p

def _setupLogging(stream, level, color=True):
    if isinstance(stream, str):
        stream_handler = logging.FileHandler(stream)
    else:
        stream_handler = logging.StreamHandler(stream)

    log_format = "%(levelname)-8s || %(name)-30s || %(message)s"
    stream_handler.formatter = logging.Formatter(log_format)
    logging.root.addHandler(stream_handler)
    logging.root.setLevel(level)


def setupLogging():
    log_path = '/tmp'
    log_file = p.join(log_path, 'vim-hdl.log')
    index = 0
    while True:
        try:
            open(log_file, 'a').close()
            break
        except IOError:
            log_file = p.join(log_path, 'vim_log_%d_%d.log' % (os.getpid(), index))
            index += 1
    logging.getLogger('requests').setLevel(logging.WARNING)
    logging.getLogger('nose2').setLevel(logging.INFO)
    logging.getLogger('neovim').setLevel(logging.INFO)
    _setupLogging(log_file, logging.DEBUG, True)

setupLogging()

_logger = logging.getLogger(__name__)

import vim

try:
    import coverage
    _logger.info("Coverage module succesfully imported")
    cov = coverage.Coverage(config_file='.coveragerc')
    cov.start()

    def onVimLeave():
        global cov
        cov.stop()
        cov.save()

except:
    _logger.fatal("Unable to import 'coverage'")
    def onVimLeave():
        _logger.warning("No coverage started, can't stop it")

EOF
    autocmd! VimLeavePre * :silent! call s:Pyeval('onVimLeave()')

endfunction

call s:SetupPythonEnv()

